<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neural Conductivity Gradient: Electron Flow in the Brain</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background-color: #0a0e17;
            color: #e0f0ff;
            line-height: 1.6;
            overflow-x: hidden;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            text-align: center;
            padding: 40px 20px;
            background: linear-gradient(135deg, #0c1a2d 0%, #0a0e17 100%);
            border-bottom: 1px solid #1a3a5f;
            border-radius: 0 0 20px 20px;
            margin-bottom: 30px;
        }
        
        h1 {
            font-size: 2.8rem;
            margin-bottom: 15px;
            background: linear-gradient(90deg, #4d9fff, #8a5fff);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: 0 0 20px rgba(77, 159, 255, 0.3);
        }
        
        .subtitle {
            font-size: 1.2rem;
            color: #a0c8ff;
            max-width: 800px;
            margin: 0 auto 25px;
        }
        
        .main-content {
            display: flex;
            flex-wrap: wrap;
            gap: 30px;
            margin-bottom: 40px;
        }
        
        .visualization-container {
            flex: 1 1 700px;
            background: #0c1525;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0, 10, 30, 0.5);
            border: 1px solid #1a3a5f;
            position: relative;
            overflow: hidden;
            min-height: 600px;
        }
        
        .controls-panel {
            flex: 1 1 300px;
            background: #0c1525;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0, 10, 30, 0.5);
            border: 1px solid #1a3a5f;
        }
        
        .panel-title {
            font-size: 1.5rem;
            color: #6ab1ff;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid #1a3a5f;
        }
        
        .control-group {
            margin-bottom: 25px;
        }
        
        .control-label {
            display: block;
            margin-bottom: 8px;
            color: #a0c8ff;
            font-weight: 600;
        }
        
        .slider-container {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .slider-value {
            min-width: 40px;
            text-align: center;
            background: #152238;
            padding: 5px 10px;
            border-radius: 5px;
            font-weight: bold;
            color: #6ab1ff;
        }
        
        input[type="range"] {
            flex: 1;
            -webkit-appearance: none;
            height: 8px;
            background: #152238;
            border-radius: 4px;
            outline: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: #4d9fff;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(77, 159, 255, 0.7);
        }
        
        .btn {
            display: block;
            width: 100%;
            padding: 12px;
            margin-bottom: 12px;
            background: linear-gradient(90deg, #1a5cb0, #3a2ca0);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(77, 159, 255, 0.4);
        }
        
        .btn:active {
            transform: translateY(0);
        }
        
        .explanation {
            background: #0c1525;
            border-radius: 15px;
            padding: 30px;
            margin-top: 30px;
            box-shadow: 0 10px 30px rgba(0, 10, 30, 0.5);
            border: 1px solid #1a3a5f;
        }
        
        .explanation h2 {
            color: #6ab1ff;
            margin-bottom: 20px;
            font-size: 1.8rem;
        }
        
        .explanation p {
            margin-bottom: 15px;
            color: #c0d8ff;
        }
        
        .key-points {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 25px;
        }
        
        .point {
            background: #152238;
            padding: 20px;
            border-radius: 10px;
            border-left: 4px solid #4d9fff;
        }
        
        .point h3 {
            color: #8a5fff;
            margin-bottom: 10px;
        }
        
        footer {
            text-align: center;
            padding: 30px;
            margin-top: 40px;
            color: #7890b0;
            border-top: 1px solid #1a3a5f;
            font-size: 0.9rem;
        }
        
        #neuralCanvas {
            width: 100%;
            height: 100%;
            border-radius: 8px;
        }
        
        .canvas-container {
            width: 100%;
            height: 550px;
            position: relative;
        }
        
        .neuron {
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: radial-gradient(circle, #ff5e7d, #a80028);
            box-shadow: 0 0 15px rgba(255, 94, 125, 0.7);
            z-index: 10;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .neuron.active {
            background: radial-gradient(circle, #4dffea, #00a895);
            box-shadow: 0 0 25px rgba(77, 255, 234, 0.9);
            transform: scale(1.3);
        }
        
        .pulse {
            position: absolute;
            border-radius: 50%;
            border: 2px solid rgba(77, 159, 255, 0.8);
            animation: pulse-animation 1.5s infinite;
        }
        
        @keyframes pulse-animation {
            0% { transform: scale(0.1); opacity: 1; }
            100% { transform: scale(2); opacity: 0; }
        }
        
        .gradient-line {
            position: absolute;
            height: 3px;
            background: linear-gradient(90deg, rgba(77, 159, 255, 0.8), rgba(138, 95, 255, 0.4));
            transform-origin: left center;
            z-index: 1;
        }
        
        .conductivity-label {
            position: absolute;
            background: rgba(10, 14, 23, 0.8);
            color: #6ab1ff;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 0.8rem;
            pointer-events: none;
            z-index: 20;
        }
        
        .info-display {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(10, 14, 23, 0.85);
            border: 1px solid #1a3a5f;
            border-radius: 10px;
            padding: 15px;
            max-width: 300px;
            z-index: 100;
        }
        
        .info-display h3 {
            color: #4dffea;
            margin-bottom: 10px;
            font-size: 1.1rem;
        }
        
        .info-display p {
            font-size: 0.9rem;
            line-height: 1.4;
        }
        
        @media (max-width: 1100px) {
            .main-content {
                flex-direction: column;
            }
            
            .visualization-container, .controls-panel {
                flex: 1 1 auto;
            }
        }
        
        @media (max-width: 768px) {
            h1 {
                font-size: 2rem;
            }
            
            .canvas-container {
                height: 450px;
            }
            
            .key-points {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <header>
        <div class="container">
            <h1>Neural Conductivity Gradient</h1>
            <p class="subtitle">Visualizing how neural activity emerges from electron flow probability gradients in the brain's conductive field</p>
        </div>
    </header>
    
    <div class="container">
        <div class="main-content">
            <div class="visualization-container">
                <h2 class="panel-title">Neural Electron Flow Field</h2>
                <div class="canvas-container">
                    <canvas id="neuralCanvas"></canvas>
                    <div class="info-display">
                        <h3>Current Activity</h3>
                        <p>Active neurons: <span id="activeNeurons">0</span></p>
                        <p>Signal propagation: <span id="signalSpeed">0</span> neurons/sec</p>
                        <p>Avg. conductivity: <span id="avgConductivity">0.0</span> Î¼S/mm</p>
                    </div>
                </div>
            </div>
            
            <div class="controls-panel">
                <h2 class="panel-title">Simulation Controls</h2>
                
                <div class="control-group">
                    <label class="control-label">Neural Activity Level</label>
                    <div class="slider-container">
                        <input type="range" id="activitySlider" min="0" max="100" value="30">
                        <span class="slider-value" id="activityValue">30%</span>
                    </div>
                </div>
                
                <div class="control-group">
                    <label class="control-label">Conductivity Gradient</label>
                    <div class="slider-container">
                        <input type="range" id="gradientSlider" min="1" max="10" value="5">
                        <span class="slider-value" id="gradientValue">5</span>
                    </div>
                </div>
                
                <div class="control-group">
                    <label class="control-label">Electron Flow Speed</label>
                    <div class="slider-container">
                        <input type="range" id="speedSlider" min="1" max="10" value="5">
                        <span class="slider-value" id="speedValue">5</span>
                    </div>
                </div>
                
                <button class="btn" id="stimulateBtn">
                    <i class="fas fa-bolt"></i> Stimulate Neural Region
                </button>
                
                <button class="btn" id="resetBtn">
                    <i class="fas fa-redo"></i> Reset Simulation
                </button>
                
                <button class="btn" id="autoBtn">
                    <i class="fas fa-play"></i> Auto-Cycle Activity
                </button>
                
                <div class="control-group" style="margin-top: 25px;">
                    <h3 class="panel-title" style="font-size: 1.2rem;">Visualization Mode</h3>
                    <div style="display: flex; gap: 10px; margin-top: 10px;">
                        <button class="btn" id="mode1Btn" style="padding: 8px; background: #1a5cb0;">Electron Flow</button>
                        <button class="btn" id="mode2Btn" style="padding: 8px; background: #152238;">Conductivity Map</button>
                        <button class="btn" id="mode3Btn" style="padding: 8px; background: #152238;">Signal Pathways</button>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="explanation">
            <h2>The Neural Gradient Descent Field</h2>
            <p>Neural signaling is fundamentally mediated by electron flow along conductivity gradients in brain tissue. This visualization demonstrates how areas of higher relative conductivity create probability fields that guide electron movement, forming the basis of all neural information processing.</p>
            
            <div class="key-points">
                <div class="point">
                    <h3>Conductivity Gradients</h3>
                    <p>Neural tissue exhibits varying conductivity based on ion concentration, myelination, and cellular density. These variations create natural pathways for electron flow.</p>
                </div>
                
                <div class="point">
                    <h3>Electron Probability Fields</h3>
                    <p>Electrons follow paths of least resistance, creating probability distributions that can be modeled as gradient descent fields in the brain's conductive medium.</p>
                </div>
                
                <div class="point">
                    <h3>Information Encoding</h3>
                    <p>Neural information is encoded in the spatiotemporal patterns of electron flow across these conductivity gradients, not in individual neuron firing events.</p>
                </div>
            </div>
        </div>
    </div>
    
    <footer>
        <div class="container">
            <p>Neural Conductivity Gradient Visualization | A simulation of electron flow probability in neural tissue</p>
            <p>Concept: Neural signaling as gradient descent in a conductive field | Interactive visualization for educational purposes</p>
        </div>
    </footer>

    <script>
        // Canvas and rendering context
        const canvas = document.getElementById('neuralCanvas');
        const ctx = canvas.getContext('2d');
        
        // Set canvas dimensions
        function resizeCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
        }
        
        // Initialize canvas size
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // Simulation state
        let simulation = {
            neurons: [],
            connections: [],
            activityLevel: 0.3,
            gradientStrength: 5,
            flowSpeed: 5,
            isAutoCycling: false,
            autoCycleInterval: null,
            visualizationMode: 1, // 1: Electron Flow, 2: Conductivity Map, 3: Signal Pathways
            activeNeurons: 0,
            lastUpdate: Date.now()
        };
        
        // Neuron class
        class Neuron {
            constructor(x, y, id) {
                this.x = x;
                this.y = y;
                this.id = id;
                this.radius = 10;
                this.baseConductivity = 0.3 + Math.random() * 0.7;
                this.currentConductivity = this.baseConductivity;
                this.isActive = false;
                this.activationLevel = 0;
                this.activationDecay = 0.05;
                this.connections = [];
                this.color = this.getColor();
            }
            
            getColor() {
                // Color based on conductivity
                const conductivity = this.currentConductivity;
                const r = Math.floor(80 + conductivity * 175);
                const g = Math.floor(100 + conductivity * 100);
                const b = Math.floor(150 + conductivity * 105);
                return `rgb(${r}, ${g}, ${b})`;
            }
            
            activate() {
                this.isActive = true;
                this.activationLevel = 1.0;
                this.currentConductivity = this.baseConductivity * 1.5;
                
                // Create a visual pulse
                createPulse(this.x, this.y);
                
                // Possibly activate connected neurons
                if (Math.random() < 0.3) {
                    setTimeout(() => {
                        this.connections.forEach(conn => {
                            if (Math.random() < simulation.activityLevel) {
                                const targetNeuron = simulation.neurons[conn.targetId];
                                if (targetNeuron && !targetNeuron.isActive) {
                                    targetNeuron.activate();
                                }
                            }
                        });
                    }, 50);
                }
            }
            
            update() {
                // Decay activation
                if (this.isActive) {
                    this.activationLevel -= this.activationDecay * (0.5 + Math.random() * 1);
                    this.currentConductivity = this.baseConductivity * (1 + this.activationLevel * 0.5);
                    
                    if (this.activationLevel <= 0) {
                        this.isActive = false;
                        this.activationLevel = 0;
                        this.currentConductivity = this.baseConductivity;
                    }
                }
                
                // Slight random fluctuations in conductivity
                this.currentConductivity += (Math.random() - 0.5) * 0.01;
                this.currentConductivity = Math.max(0.1, Math.min(1, this.currentConductivity));
                
                this.color = this.getColor();
            }
            
            draw() {
                // Draw neuron
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                
                if (this.isActive) {
                    // Active neuron gradient
                    const gradient = ctx.createRadialGradient(
                        this.x, this.y, 0,
                        this.x, this.y, this.radius * 1.5
                    );
                    gradient.addColorStop(0, 'rgba(77, 255, 234, 0.9)');
                    gradient.addColorStop(0.7, 'rgba(77, 255, 234, 0.4)');
                    gradient.addColorStop(1, 'rgba(77, 255, 234, 0.1)');
                    ctx.fillStyle = gradient;
                } else {
                    // Inactive neuron gradient
                    const gradient = ctx.createRadialGradient(
                        this.x, this.y, 0,
                        this.x, this.y, this.radius * 1.5
                    );
                    gradient.addColorStop(0, this.color);
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                    ctx.fillStyle = gradient;
                }
                
                ctx.fill();
                
                // Draw neuron border
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.lineWidth = 2;
                ctx.strokeStyle = this.isActive ? '#4dffea' : '#2a5caa';
                ctx.stroke();
                
                // Draw activation level if active
                if (this.isActive) {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius * this.activationLevel, 0, Math.PI * 2);
                    ctx.lineWidth = 1;
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                    ctx.stroke();
                }
            }
        }
        
        // Connection class
        class Connection {
            constructor(sourceId, targetId, strength) {
                this.sourceId = sourceId;
                this.targetId = targetId;
                this.strength = strength;
                this.active = false;
                this.activityLevel = 0;
            }
            
            draw(sourceX, sourceY, targetX, targetY) {
                const sourceNeuron = simulation.neurons[this.sourceId];
                const targetNeuron = simulation.neurons[this.targetId];
                
                if (!sourceNeuron || !targetNeuron) return;
                
                ctx.beginPath();
                ctx.moveTo(sourceX, sourceY);
                ctx.lineTo(targetX, targetY);
                
                // Line style based on conductivity and activity
                let lineWidth = 1 + (sourceNeuron.currentConductivity * 2);
                let alpha = 0.2 + (sourceNeuron.currentConductivity * 0.3);
                
                if (this.active) {
                    lineWidth = 2 + (this.activityLevel * 3);
                    alpha = 0.1 + this.activityLevel * 0.7;
                    this.activityLevel -= 0.05;
                    if (this.activityLevel <= 0) this.active = false;
                }
                
                // Different visualization modes
                if (simulation.visualizationMode === 1) {
                    // Electron flow mode
                    ctx.strokeStyle = `rgba(100, 180, 255, ${alpha})`;
                } else if (simulation.visualizationMode === 2) {
                    // Conductivity map mode
                    const conductivity = (sourceNeuron.currentConductivity + targetNeuron.currentConductivity) / 2;
                    ctx.strokeStyle = `rgba(${100 + conductivity * 155}, ${100 + conductivity * 100}, 255, ${alpha})`;
                } else {
                    // Signal pathways mode
                    ctx.strokeStyle = `rgba(150, 255, 200, ${alpha})`;
                }
                
                ctx.lineWidth = lineWidth;
                ctx.stroke();
                
                // Draw electron flow along the connection if active
                if (this.active && simulation.visualizationMode === 1) {
                    const progress = 1 - (this.activityLevel / 1.0);
                    const electronX = sourceX + (targetX - sourceX) * progress;
                    const electronY = sourceY + (targetY - sourceY) * progress;
                    
                    ctx.beginPath();
                    ctx.arc(electronX, electronY, 3, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(255, 255, 200, 0.9)';
                    ctx.fill();
                    
                    ctx.beginPath();
                    ctx.arc(electronX, electronY, 5, 0, Math.PI * 2);
                    ctx.strokeStyle = 'rgba(255, 255, 200, 0.5)';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
            }
        }
        
        // Pulse animation for active neurons
        const pulses = [];
        
        function createPulse(x, y) {
            pulses.push({
                x, y,
                radius: 5,
                maxRadius: 50,
                alpha: 0.8,
                growthRate: 2
            });
        }
        
        function updatePulses() {
            for (let i = pulses.length - 1; i >= 0; i--) {
                const pulse = pulses[i];
                pulse.radius += pulse.growthRate;
                pulse.alpha -= 0.02;
                
                if (pulse.alpha <= 0) {
                    pulses.splice(i, 1);
                }
            }
        }
        
        function drawPulses() {
            pulses.forEach(pulse => {
                ctx.beginPath();
                ctx.arc(pulse.x, pulse.y, pulse.radius, 0, Math.PI * 2);
                ctx.strokeStyle = `rgba(77, 159, 255, ${pulse.alpha})`;
                ctx.lineWidth = 2;
                ctx.stroke();
            });
        }
        
        // Initialize the neural network
        function initNeuralNetwork() {
            simulation.neurons = [];
            simulation.connections = [];
            pulses.length = 0;
            
            // Create neurons
            const neuronCount = 40;
            const padding = 40;
            
            for (let i = 0; i < neuronCount; i++) {
                // Distribute neurons in clusters
                let x, y;
                if (i < 10) {
                    // Left cluster
                    x = padding + Math.random() * (canvas.width * 0.3);
                    y = padding + Math.random() * (canvas.height - padding * 2);
                } else if (i < 20) {
                    // Top-right cluster
                    x = canvas.width * 0.6 + Math.random() * (canvas.width * 0.4 - padding);
                    y = padding + Math.random() * (canvas.height * 0.4);
                } else if (i < 30) {
                    // Bottom-right cluster
                    x = canvas.width * 0.5 + Math.random() * (canvas.width * 0.5 - padding);
                    y = canvas.height * 0.6 + Math.random() * (canvas.height * 0.4 - padding);
                } else {
                    // Central cluster
                    x = canvas.width * 0.3 + Math.random() * (canvas.width * 0.4);
                    y = canvas.height * 0.3 + Math.random() * (canvas.height * 0.4);
                }
                
                simulation.neurons.push(new Neuron(x, y, i));
            }
            
            // Create connections between neurons
            for (let i = 0; i < neuronCount; i++) {
                const sourceNeuron = simulation.neurons[i];
                const connectionCount = 3 + Math.floor(Math.random() * 4);
                
                for (let j = 0; j < connectionCount; j++) {
                    // Find a target neuron that's not too far away
                    let targetId;
                    let attempts = 0;
                    
                    do {
                        targetId = Math.floor(Math.random() * neuronCount);
                        attempts++;
                    } while (targetId === i || attempts < 20);
                    
                    // Calculate distance
                    const targetNeuron = simulation.neurons[targetId];
                    const dx = targetNeuron.x - sourceNeuron.x;
                    const dy = targetNeuron.y - sourceNeuron.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    // Only connect if within reasonable distance
                    if (distance < 300) {
                        const strength = 0.5 + Math.random() * 0.5;
                        const connection = new Connection(i, targetId, strength);
                        simulation.connections.push(connection);
                        sourceNeuron.connections.push(connection);
                    }
                }
            }
            
            // Activate a few neurons to start
            for (let i = 0; i < 3; i++) {
                const randomNeuron = simulation.neurons[Math.floor(Math.random() * simulation.neurons.length)];
                setTimeout(() => {
                    randomNeuron.activate();
                }, i * 300);
            }
        }
        
        // Draw conductivity gradient background
        function drawConductivityField() {
            if (simulation.visualizationMode !== 2) return;
            
            const gridSize = 30;
            const gradient = simulation.gradientStrength / 10;
            
            for (let x = 0; x < canvas.width; x += gridSize) {
                for (let y = 0; y < canvas.height; y += gridSize) {
                    // Calculate conductivity at this point based on neuron proximity
                    let conductivity = 0;
                    
                    simulation.neurons.forEach(neuron => {
                        const dx = x - neuron.x;
                        const dy = y - neuron.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < 200) {
                            const influence = (1 - distance / 200) * neuron.currentConductivity;
                            conductivity += influence;
                        }
                    });
                    
                    conductivity = Math.min(1, conductivity * gradient);
                    
                    // Draw conductivity cell
                    const alpha = 0.1 + conductivity * 0.3;
                    const blueValue = 100 + conductivity * 155;
                    
                    ctx.fillStyle = `rgba(50, 100, ${blueValue}, ${alpha})`;
                    ctx.fillRect(x, y, gridSize, gridSize);
                    
                    // Draw contour lines for conductivity gradients
                    if (conductivity > 0.3 && conductivity < 0.7) {
                        ctx.strokeStyle = `rgba(100, 200, 255, ${0.1 + conductivity * 0.2})`;
                        ctx.lineWidth = 1;
                        ctx.strokeRect(x, y, gridSize, gridSize);
                    }
                }
            }
        }
        
        // Draw electron flow probability field
        function drawProbabilityField() {
            if (simulation.visualizationMode !== 1) return;
            
            // Draw gradient arrows showing electron flow direction
            const arrowSpacing = 60;
            const flowIntensity = simulation.flowSpeed / 10;
            
            ctx.strokeStyle = 'rgba(100, 200, 255, 0.15)';
            ctx.lineWidth = 1;
            ctx.fillStyle = 'rgba(150, 220, 255, 0.3)';
            
            for (let x = arrowSpacing; x < canvas.width - arrowSpacing; x += arrowSpacing) {
                for (let y = arrowSpacing; y < canvas.height - arrowSpacing; y += arrowSpacing) {
                    // Calculate flow direction based on neuron conductivity gradients
                    let flowX = 0;
                    let flowY = 0;
                    
                    simulation.neurons.forEach(neuron => {
                        if (neuron.isActive) {
                            const dx = x - neuron.x;
                            const dy = y - neuron.y;
                            const distance = Math.sqrt(dx * dx + dy * dy) + 1;
                            
                            if (distance < 150) {
                                // Flow away from active neurons (simplified model)
                                const force = (1 - distance / 150) * neuron.activationLevel * flowIntensity;
                                flowX += (dx / distance) * force;
                                flowY += (dy / distance) * force;
                            }
                        }
                    });
                    
                    // Normalize and draw arrow
                    const magnitude = Math.sqrt(flowX * flowX + flowY * flowY);
                    
                    if (magnitude > 0.1) {
                        const normX = flowX / magnitude;
                        const normY = flowY / magnitude;
                        
                        // Draw arrow
                        const arrowLength = 10 + magnitude * 20;
                        const endX = x + normX * arrowLength;
                        const endY = y + normY * arrowLength;
                        
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        ctx.lineTo(endX, endY);
                        ctx.stroke();
                        
                        // Draw arrowhead
                        const headLength = 6;
                        const angle = Math.atan2(normY, normX);
                        
                        ctx.beginPath();
                        ctx.moveTo(endX, endY);
                        ctx.lineTo(
                            endX - headLength * Math.cos(angle - Math.PI / 6),
                            endY - headLength * Math.sin(angle - Math.PI / 6)
                        );
                        ctx.lineTo(
                            endX - headLength * Math.cos(angle + Math.PI / 6),
                            endY - headLength * Math.sin(angle + Math.PI / 6)
                        );
                        ctx.closePath();
                        ctx.fill();
                    }
                }
            }
        }
        
        // Draw signal pathways
        function drawSignalPathways() {
            if (simulation.visualizationMode !== 3) return;
            
            // Highlight active pathways
            simulation.connections.forEach(connection => {
                const sourceNeuron = simulation.neurons[connection.sourceId];
                const targetNeuron = simulation.neurons[connection.targetId];
                
                if (sourceNeuron && targetNeuron && sourceNeuron.isActive) {
                    ctx.beginPath();
                    ctx.moveTo(sourceNeuron.x, sourceNeuron.y);
                    ctx.lineTo(targetNeuron.x, targetNeuron.y);
                    
                    const intensity = sourceNeuron.activationLevel * 0.7;
                    ctx.strokeStyle = `rgba(100, 255, 200, ${intensity})`;
                    ctx.lineWidth = 1 + intensity * 3;
                    ctx.stroke();
                    
                    // Draw direction indicator
                    const midX = sourceNeuron.x + (targetNeuron.x - sourceNeuron.x) * 0.5;
                    const midY = sourceNeuron.y + (targetNeuron.y - sourceNeuron.y) * 0.5;
                    
                    ctx.fillStyle = `rgba(100, 255, 200, ${intensity})`;
                    ctx.beginPath();
                    ctx.arc(midX, midY, 2 + intensity * 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
        }
        
        // Update simulation stats
        function updateStats() {
            const now = Date.now();
            const deltaTime = now - simulation.lastUpdate;
            
            // Count active neurons
            simulation.activeNeurons = simulation.neurons.filter(n => n.isActive).length;
            
            // Calculate average conductivity
            let totalConductivity = 0;
            simulation.neurons.forEach(neuron => {
                totalConductivity += neuron.currentConductivity;
            });
            const avgConductivity = totalConductivity / simulation.neurons.length;
            
            // Update display
            document.getElementById('activeNeurons').textContent = simulation.activeNeurons;
            document.getElementById('signalSpeed').textContent = Math.floor(simulation.activeNeurons * simulation.flowSpeed * 0.5);
            document.getElementById('avgConductivity').textContent = avgConductivity.toFixed(2);
            
            simulation.lastUpdate = now;
        }
        
        // Main animation loop
        function animate() {
            // Clear canvas with a dark background
            ctx.fillStyle = '#0a0e17';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw visualization background based on mode
            drawConductivityField();
            drawProbabilityField();
            drawSignalPathways();
            
            // Update and draw neurons
            simulation.neurons.forEach(neuron => {
                neuron.update();
            });
            
            // Draw connections
            simulation.connections.forEach(connection => {
                const sourceNeuron = simulation.neurons[connection.sourceId];
                const targetNeuron = simulation.neurons[connection.targetId];
                
                if (sourceNeuron && targetNeuron) {
                    connection.draw(sourceNeuron.x, sourceNeuron.y, targetNeuron.x, targetNeuron.y);
                }
            });
            
            // Draw neurons on top of connections
            simulation.neurons.forEach(neuron => {
                neuron.draw();
            });
            
            // Update and draw pulses
            updatePulses();
            drawPulses();
            
            // Update statistics
            updateStats();
            
            // Request next frame
            requestAnimationFrame(animate);
        }
        
        // Initialize and start simulation
        initNeuralNetwork();
        animate();
        
        // Event listeners for controls
        
        // Activity slider
        const activitySlider = document.getElementById('activitySlider');
        const activityValue = document.getElementById('activityValue');
        
        activitySlider.addEventListener('input', function() {
            const value = this.value;
            activityValue.textContent = value + '%';
            simulation.activityLevel = value / 100;
        });
        
        // Gradient slider
        const gradientSlider = document.getElementById('gradientSlider');
        const gradientValue = document.getElementById('gradientValue');
        
        gradientSlider.addEventListener('input', function() {
            const value = this.value;
            gradientValue.textContent = value;
            simulation.gradientStrength = value;
        });
        
        // Speed slider
        const speedSlider = document.getElementById('speedSlider');
        const speedValue = document.getElementById('speedValue');
        
        speedSlider.addEventListener('input', function() {
            const value = this.value;
            speedValue.textContent = value;
            simulation.flowSpeed = value;
        });
        
        // Stimulate button
        document.getElementById('stimulateBtn').addEventListener('click', function() {
            // Activate a random cluster of neurons
            const clusterCenter = Math.floor(Math.random() * simulation.neurons.length);
            const clusterSize = 3 + Math.floor(Math.random() * 5);
            
            for (let i = 0; i < clusterSize; i++) {
                const randomIndex = Math.floor(Math.random() * simulation.neurons.length);
                setTimeout(() => {
                    simulation.neurons[randomIndex].activate();
                    
                    // Activate connections from this neuron
                    simulation.neurons[randomIndex].connections.forEach(conn => {
                        conn.active = true;
                        conn.activityLevel = 1.0;
                    });
                }, i * 100);
            }
            
            // Visual feedback
            this.style.background = 'linear-gradient(90deg, #2a7cdd, #4a3cd0)';
            setTimeout(() => {
                this.style.background = 'linear-gradient(90deg, #1a5cb0, #3a2ca0)';
            }, 300);
        });
        
        // Reset button
        document.getElementById('resetBtn').addEventListener('click', function() {
            initNeuralNetwork();
            
            // Reset sliders to default
            activitySlider.value = 30;
            activityValue.textContent = '30%';
            simulation.activityLevel = 0.3;
            
            gradientSlider.value = 5;
            gradientValue.textContent = '5';
            simulation.gradientStrength = 5;
            
            speedSlider.value = 5;
            speedValue.textContent = '5';
            simulation.flowSpeed = 5;
            
            // Stop auto-cycle if active
            if (simulation.isAutoCycling) {
                clearInterval(simulation.autoCycleInterval);
                simulation.isAutoCycling = false;
                document.getElementById('autoBtn').innerHTML = '<i class="fas fa-play"></i> Auto-Cycle Activity';
            }
        });
        
        // Auto-cycle button
        document.getElementById('autoBtn').addEventListener('click', function() {
            simulation.isAutoCycling = !simulation.isAutoCycling;
            
            if (simulation.isAutoCycling) {
                this.innerHTML = '<i class="fas fa-pause"></i> Stop Auto-Cycle';
                
                simulation.autoCycleInterval = setInterval(() => {
                    // Activate a random neuron
                    const randomNeuron = simulation.neurons[Math.floor(Math.random() * simulation.neurons.length)];
                    randomNeuron.activate();
                    
                    // Occasionally activate a cluster
                    if (Math.random() < 0.3) {
                        const clusterStart = Math.floor(Math.random() * (simulation.neurons.length - 3));
                        for (let i = 0; i < 3; i++) {
                            setTimeout(() => {
                                simulation.neurons[clusterStart + i].activate();
                            }, i * 200);
                        }
                    }
                }, 800);
            } else {
                this.innerHTML = '<i class="fas fa-play"></i> Auto-Cycle Activity';
                clearInterval(simulation.autoCycleInterval);
            }
        });
        
        // Visualization mode buttons
        document.getElementById('mode1Btn').addEventListener('click', function() {
            simulation.visualizationMode = 1;
            updateModeButtons();
        });
        
        document.getElementById('mode2Btn').addEventListener('click', function() {
            simulation.visualizationMode = 2;
            updateModeButtons();
        });
        
        document.getElementById('mode3Btn').addEventListener('click', function() {
            simulation.visualizationMode = 3;
            updateModeButtons();
        });
        
        function updateModeButtons() {
            const mode1Btn = document.getElementById('mode1Btn');
            const mode2Btn = document.getElementById('mode2Btn');
            const mode3Btn = document.getElementById('mode3Btn');
            
            // Reset all buttons
            mode1Btn.style.background = '#152238';
            mode2Btn.style.background = '#152238';
            mode3Btn.style.background = '#152238';
            
            // Highlight active mode
            if (simulation.visualizationMode === 1) {
                mode1Btn.style.background = '#1a5cb0';
            } else if (simulation.visualizationMode === 2) {
                mode2Btn.style.background = '#1a5cb0';
            } else {
                mode3Btn.style.background = '#1a5cb0';
            }
        }
        
        // Initialize mode buttons
        updateModeButtons();
        
        // Click on canvas to activate neurons
        canvas.addEventListener('click', function(event) {
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            // Find nearest neuron
            let nearestNeuron = null;
            let minDistance = Infinity;
            
            simulation.neurons.forEach(neuron => {
                const dx = x - neuron.x;
                const dy = y - neuron.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < minDistance && distance < 50) {
                    minDistance = distance;
                    nearestNeuron = neuron;
                }
            });
            
            // Activate the neuron if found
            if (nearestNeuron) {
                nearestNeuron.activate();
                
                // Also activate nearby neurons
                simulation.neurons.forEach(neuron => {
                    const dx = neuron.x - nearestNeuron.x;
                    const dy = neuron.y - nearestNeuron.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < 80 && neuron !== nearestNeuron && Math.random() < 0.5) {
                        setTimeout(() => {
                            neuron.activate();
                        }, 100);
                    }
                });
            } else {
                // Create a conductivity pulse at click location
                createPulse(x, y);
            }
        });
        
        // Initialize with a few active neurons
        setTimeout(() => {
            simulation.neurons[10].activate();
            simulation.neurons[15].activate();
            simulation.neurons[25].activate();
        }, 1000);
    </script>
</body>
</html>
